WGCNA
================
Jennifer Chang
1/8/2021

## Correlaion Network Analysis

-   [WGCNA
    Tutorial](https://bioinformaticsworkbook.org/tutorials/wgcna#gsc.tab=0)

## Install any required libraries

``` r
# == Install any CRAN packages
# cran_pkgs <- c("WGCNA")
# install.packages(cran_pkgs)

# == Install any Bioconductor packages
# bioc_pkgs <- c("DESeq2")
# BiocManager::install(bioc_pkgs)

# ====================   Year of development
library(tidyverse)
library(magrittr)
library(WGCNA)         # 2008    # <= originally developed for microarray data
library(DESeq2)        # 2014    # <= using this for normalization for now... can use any normalization program
```

# Load in normalized data

For now, we’ll do a quick normalization using DESeq2 but this should be
replaced with whichever normalization method preferred.

Load in the RNAseq counts generated by GSNAP.

``` r
data_maize <- read_delim("maize_genecounts.txt", delim = "\t")
#> 
#> ── Column specification ────────────────────────────────────────────────────────
#> cols(
#>   .default = col_double(),
#>   Geneid = col_character()
#> )
#> ℹ Use `spec()` for the full column specifications.
data_bee   <- read_delim("bee_genecounts.txt", delim="\t")
#> 
#> ── Column specification ────────────────────────────────────────────────────────
#> cols(
#>   .default = col_double(),
#>   Geneid = col_character()
#> )
#> ℹ Use `spec()` for the full column specifications.
```

## DESeq2 Normalization Methods

``` r
# === Convert to Matrix
de_input = as.matrix(data_maize[,-1])
row.names(de_input) = data_maize$Geneid
de_input[1:5,1:6]
#>                   SRR1573504 SRR1573505 SRR1573506 SRR1573507 SRR1573508
#> gene-LOC103644366        732        271        409        802        263
#> gene-LOC100382519      25042       6970       8535      20928       8882
#> gene-LOC103630116         54         18          0          1          2
#> gene-LOC103649349         45         19          4         12          6
#> gene-LOC109943579          0          0          0          0          0
#>                   SRR1573509
#> gene-LOC103644366        908
#> gene-LOC100382519      18781
#> gene-LOC103630116         11
#> gene-LOC103649349         27
#> gene-LOC109943579          0

# === Prepare Metadata
meta_df <- data.frame(Sample=names(data_maize[,-1])) %>%
  mutate(
     Condition = c(rep("B", 3), rep("L", 3), rep("S", 3), rep("wtL", 3), 
                   rep("Ig1", 3), rep("B_L1", 3), rep("L_L1", 3), rep("S_L1",3)),
     Condition = factor(Condition, levels = c("wtL", "B", "L", "S", "B_L1","L_L1","S_L1", "Ig1"))
     )
meta_df[1:5,]
#>       Sample Condition
#> 1 SRR1573504         B
#> 2 SRR1573505         B
#> 3 SRR1573506         B
#> 4 SRR1573507         L
#> 5 SRR1573508         L

# === DESeq Normalization
dds <- DESeqDataSetFromMatrix(
  de_input,
  meta_df,
  design = ~Condition
)
#> converting counts to integer mode
dds <- DESeq(dds)
#> estimating size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing
vsd <- varianceStabilizingTransformation(dds)
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)
#>      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
#>  0.000000  0.000926  0.081962  0.196177  0.232638 10.377594

q_thresh <- quantile(rv_wpn, 0.85)                #<= reduced dataset here! Come back to reevaluate this threshold again
expr_normalized <- wpn_vsd[ rv_wpn > q_thresh,]
dim(expr_normalized)
#> [1] 6706   24
```

# Start WGCNA

``` r
# Normalized expression (altho this is also thresholded)
expr_normalized[1:5,1:6]
#>                   SRR1573504 SRR1573505 SRR1573506 SRR1573507 SRR1573508
#> gene-LOC115032971   7.708386   7.871048   7.957873   7.954386   8.124903
#> gene-LOC103630195   9.979569   9.888200   9.845625  10.847190  10.618372
#> gene-LOC109943573   6.391942   6.452783   6.847547   6.543068   6.376092
#> gene-LOC100216975  10.277950  10.237616  10.368051  10.532639  10.601437
#> gene-LOC100279889  10.619304  10.832105  10.509811   9.759627   9.982168
#>                   SRR1573509
#> gene-LOC115032971   9.045603
#> gene-LOC103630195  10.079612
#> gene-LOC109943573   6.615451
#> gene-LOC100216975  11.023595
#> gene-LOC100279889  10.911437

wgcna_input = t(expr_normalized)      # WGCNA input is the transpose of DESeq2 output

allowWGCNAThreads()                   # multithreading
#> Allowing multi-threading with up to 4 threads.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  wgcna_input,             # <= Input data
  #blockSize = 30,
  powerVector = powers,
  verbose = 5
  )
#> pickSoftThreshold: will use block size 6671.
#>  pickSoftThreshold: calculating connectivity for given powers...
#>    ..working on genes 1 through 6671 of 6706
#>    ..working on genes 6672 through 6706 of 6706
#>    Power SFT.R.sq  slope truncated.R.sq mean.k. median.k. max.k.
#> 1      1   0.4350  2.030          0.966  2340.0   2350.00   3430
#> 2      2   0.0214  0.206          0.898  1150.0   1130.00   2200
#> 3      3   0.1410 -0.436          0.874   670.0    624.00   1560
#> 4      4   0.4160 -0.787          0.870   432.0    375.00   1180
#> 5      5   0.5700 -0.987          0.836   300.0    238.00    927
#> 6      6   0.6450 -1.100          0.791   220.0    157.00    754
#> 7      7   0.7110 -1.080          0.748   169.0    108.00    630
#> 8      8   0.8510 -1.010          0.818   134.0     76.20    538
#> 9      9   0.9380 -0.972          0.938   110.0     54.90    479
#> 10    10   0.9320 -1.030          0.937    92.0     40.60    460
#> 11    12   0.9150 -1.070          0.936    68.3     22.90    429
#> 12    14   0.8850 -1.080          0.921    53.7     13.70    404
#> 13    16   0.8690 -1.060          0.926    44.0      8.51    383
#> 14    18   0.8420 -1.040          0.919    37.1      5.47    363
#> 15    20   0.8310 -1.020          0.920    32.0      3.59    345

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")
```

![](imgs/4_WGCNAsoftpower-1.png)<!-- -->

Maybe a power of 8 or 9.

``` r
picked_power = 9
temp_cor <- cor       
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(wgcna_input,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 30,
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          saveTOMFileBase = "temp",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
#>  Calculating module eigengenes block-wise from all genes
#>    Flagging genes and samples with too many missing values...
#>     ..step 1
#>  ....pre-clustering genes to determine blocks..
#>    Projective K-means:
#>    ..k-means clustering..
#>    ..merging smaller clusters...
#> Block sizes:
#> gBlocks
#>    1    2 
#> 3544 3162 
#>  ..Working on block 1 .
#>     TOM calculation: adjacency..
#>     ..will use 4 parallel threads.
#>      Fraction of slow calculations: 0.000000
#>     ..connectivity..
#>     ..matrix multiplication (system BLAS)..
#>     ..normalization..
#>     ..done.
#>    ..saving TOM for block 1 into file temp-block.1.RData
#>  ....clustering..
#>  ....detecting modules..
#>  ....calculating module eigengenes..
#>  ....checking kME in modules..
#>      ..removing 39 genes from module 1 because their KME is too low.
#>      ..removing 11 genes from module 2 because their KME is too low.
#>      ..removing 2 genes from module 3 because their KME is too low.
#>      ..removing 2 genes from module 4 because their KME is too low.
#>      ..removing 2 genes from module 5 because their KME is too low.
#>  ..Working on block 2 .
#>     TOM calculation: adjacency..
#>     ..will use 4 parallel threads.
#>      Fraction of slow calculations: 0.000000
#>     ..connectivity..
#>     ..matrix multiplication (system BLAS)..
#>     ..normalization..
#>     ..done.
#>    ..saving TOM for block 2 into file temp-block.2.RData
#>  ....clustering..
#>  ....detecting modules..
#>  ....calculating module eigengenes..
#>  ....checking kME in modules..
#>      ..removing 44 genes from module 1 because their KME is too low.
#>      ..removing 90 genes from module 2 because their KME is too low.
#>      ..removing 26 genes from module 3 because their KME is too low.
#>      ..removing 1 genes from module 5 because their KME is too low.
#>      ..removing 16 genes from module 6 because their KME is too low.
#>  ..merging modules that are too close..
#>      mergeCloseModules: Merging modules whose distance is less than 0.25
#>        Calculating new MEs...
```

Generate the Dendrogram and view modules

``` r
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
```

![](imgs/4_WGCNAdendrogram-1.png)<!-- -->

Write modules to file

``` r
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]
#>             gene_id colors
#> 1 gene-LOC115032971  green
#> 2 gene-LOC103630195  brown
#> 3 gene-LOC109943573   blue
#> 4 gene-LOC100216975    red
#> 5 gene-LOC100279889    red

write_delim(module_df,
            file = "maize_gene_modules.txt",
            delim = "\t")
```

Relate modules to treatment

``` r
# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(wgcna_input, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

# TODO: swap in the meta data labels
mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
```

![](imgs/4_WGCNAmoduletraits-1.png)<!-- -->
