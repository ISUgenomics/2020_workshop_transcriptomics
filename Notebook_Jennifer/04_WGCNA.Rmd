---
title: "WGCNA"
author: "Jennifer Chang"
date: "1/8/2021"
output:
  github_document
editor_options:
  chunck_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "imgs/4_WGCNA"
)
```

## Correlaion Network Analysis

* [WGCNA Tutorial](https://bioinformaticsworkbook.org/tutorials/wgcna#gsc.tab=0)

## Install any required libraries

```{r, warning=FALSE, message=FALSE}
# == Install any CRAN packages
# cran_pkgs <- c("WGCNA")
# install.packages(cran_pkgs)

# == Install any Bioconductor packages
# bioc_pkgs <- c("DESeq2")
# BiocManager::install(bioc_pkgs)

# ====================   Year of development
library(tidyverse)
library(magrittr)
library(WGCNA)         # 2008    # <= originally developed for microarray data
library(DESeq2)        # 2014    # <= using this for normalization for now... can use any normalization program
```

# Load in normalized data

For now, we'll do a quick normalization using DESeq2 but this should be replaced with whichever normalization method preferred.

Load in the RNAseq counts generated by GSNAP.

```{r}
data_maize <- read_delim("maize_genecounts.txt", delim = "\t")
data_bee   <- read_delim("bee_genecounts.txt", delim="\t")
```

## DESeq2 Normalization Methods

```{r}
# === Convert to Matrix
de_input = as.matrix(data_maize[,-1])
row.names(de_input) = data_maize$Geneid
de_input[1:5,1:6]

# === Prepare Metadata
meta_df <- data.frame(Sample=names(data_maize[,-1])) %>%
  mutate(
     Condition = c(rep("B", 3), rep("L", 3), rep("S", 3), rep("wtL", 3), 
                   rep("Ig1", 3), rep("B_L1", 3), rep("L_L1", 3), rep("S_L1",3)),
     Condition = factor(Condition, levels = c("wtL", "B", "L", "S", "B_L1","L_L1","S_L1", "Ig1"))
     )
meta_df[1:5,]

# === DESeq Normalization
dds <- DESeqDataSetFromMatrix(
  de_input,
  meta_df,
  design = ~Condition
)
dds <- DESeq(dds)
vsd <- varianceStabilizingTransformation(dds)
wpn_vsd <- getVarianceStabilizedData(dds)
rv_wpn <- rowVars(wpn_vsd)
summary(rv_wpn)

q_thresh <- quantile(rv_wpn, 0.85)                #<= reduced dataset here! Come back to reevaluate this threshold again
expr_normalized <- wpn_vsd[ rv_wpn > q_thresh,]
dim(expr_normalized)
```

# Start WGCNA

```{r softpower, fig.width=8, fig.height=4}
# Normalized expression (altho this is also thresholded)
expr_normalized[1:5,1:6]

wgcna_input = t(expr_normalized)      # WGCNA input is the transpose of DESeq2 output

allowWGCNAThreads()                   # multithreading

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  wgcna_input,             # <= Input data
  #blockSize = 30,
  powerVector = powers,
  verbose = 5
  )

par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red")
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")
```

Maybe a power of 8 or 9.

```{r}
picked_power = 9
temp_cor <- cor       
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(wgcna_input,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 30,
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          saveTOMFileBase = "temp",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
```


Generate the Dendrogram and view modules

```{r dendrogram, fig.width=8, fig.height=3}
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
```

Write modules to file

```{r}
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]

write_delim(module_df,
            file = "maize_gene_modules.txt",
            delim = "\t")
```

Relate modules to treatment

```{r moduletraits, fig.width=6, fig.height=4}
# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(wgcna_input, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

# TODO: swap in the meta data labels
mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
```